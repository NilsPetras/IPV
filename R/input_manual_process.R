#'Input Manual Process
#'
#'Pre-processes the SEM estimates listed using \code{\link{input_manual_simple}}
#'or \code{\link{input_manual_nested}} for the use of chart functions.
#'
#'@param dat list generated by \code{\link{input_manual_simple}} or
#'  \code{\link{input_manual_nested}} with complete dat.
#'
#'@return List containing formatted dat including center distances for
#'  \code{\link{item_chart}}, \code{\link{facet_chart}}, and
#'  \code{\link{nested_chart}}.
#'
#'@seealso \code{\link{input_manual_simple}} \code{\link{input_manual_nested}}
#'
#'@examples
#'# these RSES dat can also be seen in self_confidence, the example dat of
#'# this package
#'mydat <- input_manual_simple(
#'test_name = "RSES",
#'facet_names = c("Ns", "Ps"),
#'items_per_facet = 5,
#'item_names = c(2, 5, 6, 8, 9,
#'               1, 3, 4, 7, 10),
#'test_loadings = c(.5806, .5907, .6179, .5899, .6559,
#'                     .6005, .4932, .4476, .5033, .6431),
#'facet_loadings = c(.6484, .6011, .6988, .6426, .6914,
#'                        .6422, .5835, .536, .5836, .6791),
#'correlation_matrix = matrix(dat = c(1, .69,
#'                                     .69, 1),
#'                            nrow = 2,
#'                            ncol = 2))
#'mydat
#'input_manual_process(mydat)
#'
#'@export
input_manual_process <- function(dat) {


  # nested case ----------------------------------------------------------------
  if (names(dat)[2] == "tests") {

    # checking ---------------------------------------------

    # missing dat
    if (any(unlist(lapply(dat$tests, is.na)))
    ) message("Missing dat on test. Test treated as having no facets.")

    # factor names mismatching
    if (!any(is.na(dat$tests))) {
      x <- lapply(dat$tests, `[[`, 1)
      x <- sort(as.character(unlist(lapply(x, `[[`, "factor"))))
      if (!isTRUE(all.equal(sort(as.character(dat$global$fls$subfactor)), x))
      ) stop ("Factor name or item per factor count mismatch between global
                and tests")
    }


    # item names or number of items mismatching
    if (!any(is.na(dat$tests))) {
    x <- lapply(dat$tests, `[[`, 1)
    x <- as.character(unlist(lapply(x, `[[`, "item")))
    x <- sort(paste(dat$global$fls$subfactor, sep = ".", x))
    if (!isTRUE(all.equal(sort(as.character(dat$global$fls$item)), x))
    ) stop ("Number of items or item name mismatch between global and
                tests")
    }

    # factor loadings mismatching
    if (!any(is.na(dat$tests))) {
    y <- dat$global$fls
    y <- y[order(as.character(y$subfactor), y$item),]
    x <- do.call(rbind, lapply(dat$tests, `[[`, 1))
    x <- x[order(as.character(x$factor)),]
    x$item <- paste(y$subfactor, sep = ".", x$item)
    x <- x[order(as.character(x$factor), x$item),]
    y <- y$subfactor_loading
    x <- x$factor_loading
    if (!isTRUE(all.equal(x, y))
        ) stop ("Factor loadings inconsistent between global and tests")
    }

    # processing -------------------------------------------

    mydat <- list()
    mydat$global <- input_manual_process_factor(dat$global)
    mydat$tests <- c(lapply(dat$tests[!is.na(dat$tests)], input_manual_process_factor),
    dat$tests[is.na(dat$tests)])


  # simple case ----------------------------------------------------------------

  } else {
    mydat <- input_manual_process_factor(dat)
  }


  # return ---------------------------------------------------------------------

  return(mydat)
}






#' Input Manual Process Factor
#'
#' Helper function of \code{\link{input_manual_process}}.
#'
#' @param dat list generated by \code{\link{input_manual_simple}} with complete
#'   dat.
#'
#' @return List containing formatted dat including center distances for a
#'   single factor.
input_manual_process_factor <- function(dat) {


  cds <- data.frame(
    factor = dat$fls$factor,
    subfactor = dat$fls$subfactor,
    item = as.factor(dat$fls$item),
    cd = dat$fls$subfactor_loading ^ 2 / dat$fls$factor_loading ^ 2 - 1,
    mean_cd = NA)

  # negative center distances are adjusted to zero for chart clarity
  bad <- min(cds$cd)
  bad <- bad < 0
  if (bad) message ("Negative center distance adjusted to 0")
  cds$cd[cds$cd < 0] <- 0

  mean_cds <- lapply(split(cds, cds$subfactor),
                     function (x) x$mean_cd <- mean(x$cd))
  aggregate_cds <- lapply(split(dat$fls, dat$fls$subfactor), function(x) {
    x$aggregate_cd <- max(sum(x$subfactor_loading ^ 2) / sum(x$factor_loading ^ 2) - 1, 0)
  })
  cds$mean_cd <- as.numeric(mean_cds[cds$subfactor])
  cds$aggregate_cd <- as.numeric(aggregate_cds[cds$subfactor])

  mydat <- list(cds = cds,
                 cors = dat$cors)

  return(mydat)

}
